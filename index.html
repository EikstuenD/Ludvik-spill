<!DOCTYPE html>
<html lang="no">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Tower Defense - Flere Baner</title>
<style>
   body {
     background: #222;
     color: white;
     text-align: center;
     font-family: Arial;
     margin: 0;
     padding: 0;
   }
   canvas {
     background: #333;
     margin-top: 10px;
     border: 2px solid white;
     display: block;
     margin-left: auto;
     margin-right: auto;
   }
   button {
     background-color: #444;
     border: none;
     color: white;
     padding: 10px;
     font-size: 16px;
     cursor: pointer;
   }
   button:hover {
     background-color: #555;
   }
   #levelInfo, #score, #stats {
     margin: 10px 0;
   }
</style>
</head>
<body>
<h1>Tower Defense - Flere Baner</h1>
<p>Klikk eller trykk for å plassere tårn (koster 50)</p>
<p id="stats"></p>
<p id="score">Poeng: 0</p>
<button id="startGame" onclick="startGame()">Start Spill</button>
<button id="nextLevel" onclick="nextLevel()">Neste Bane</button>
<p id="levelInfo"></p>
<canvas id="game"></canvas>
<script>
 const canvas = document.getElementById("game");
 const ctx = canvas.getContext("2d");
 let money = 100;
 let lives = 10;
 let score = 0;
 let currentLevel = 0;
 let enemies = [];
 let towers = [];
 let bullets = [];
 let gameInterval;
 let spawnInterval;
 const levels = [
   {
     name: "Bane 1",
     path: [
       {x: 0, y: 180},
       {x: 800, y: 180}
     ],
     enemySpeed: 1,
     enemyHp: 30
   },
   {
     name: "Bane 2",
     path: [
       {x: 0, y: 180},
       {x: 200, y: 100},
       {x: 600, y: 100},
       {x: 800, y: 180}
     ],
     enemySpeed: 1.5,
     enemyHp: 40
   }
 ];
 // Enemy class
 class Enemy {
   constructor(level) {
     this.x = 0;
     this.y = 180;
     this.hp = level.enemyHp;
     this.speed = level.enemySpeed;
     this.pathIndex = 0;
     this.path = level.path;
   }
   update() {
     const target = this.path[this.pathIndex];
     const dx = target.x - this.x;
     const dy = target.y - this.y;
     const dist = Math.sqrt(dx * dx + dy * dy);
     if (dist < this.speed) {
       this.pathIndex++;
       if (this.pathIndex >= this.path.length) {
         lives--;
         this.hp = 0;
       }
     } else {
       this.x += dx / dist * this.speed;
       this.y += dy / dist * this.speed;
     }
   }
   draw() {
     ctx.fillStyle = "red";
     ctx.fillRect(this.x - 10, this.y - 10, 20, 20);
   }
 }
 // Tower class
 class Tower {
   constructor(x, y) {
     this.x = x;
     this.y = y;
     this.range = 120;
     this.cooldown = 0;
     this.level = 1; // Added level to towers
   }
   update() {
     if (this.cooldown > 0) {
       this.cooldown--;
       return;
     }
     for (let enemy of enemies) {
       const dx = enemy.x - this.x;
       const dy = enemy.y - this.y;
       const dist = Math.sqrt(dx * dx + dy * dy);
       if (dist < this.range) {
         bullets.push(new Bullet(this.x, this.y, enemy));
         this.cooldown = 30; // Cooldown for shooting
         break;
       }
     }
   }
   draw() {
     ctx.fillStyle = this.level === 1 ? "blue" : "green"; // Different color for upgrades
     ctx.beginPath();
     ctx.arc(this.x, this.y, 12, 0, Math.PI * 2);
     ctx.fill();
   }
   upgrade() {
     if (money >= 100) {
       this.level++;
       this.range += 20; // Increase range for higher level
       this.cooldown -= 5; // Faster shooting rate
       money -= 100;
     }
   }
 }
 // Bullet class
 class Bullet {
   constructor(x, y, target) {
     this.x = x;
     this.y = y;
     this.target = target;
     this.speed = 4;
   }
   update() {
     if (!this.target || this.target.hp <= 0) return;
     const dx = this.target.x - this.x;
     const dy = this.target.y - this.y;
     const dist = Math.sqrt(dx * dx + dy * dy);
     if (dist < 5) {
       this.target.hp -= 10;
       if (this.target.hp <= 0) {
         score += 10;
       }
       this.dead = true;
       return;
     }
     this.x += dx / dist * this.speed;
     this.y += dy / dist * this.speed;
   }
   draw() {
     ctx.fillStyle = "yellow";
     ctx.beginPath();
     ctx.arc(this.x, this.y, 4, 0, Math.PI * 2);
     ctx.fill();
   }
 }
 // Start the game
 function startGame() {
   document.getElementById("startGame").style.display = "none";
   document.getElementById("nextLevel").style.display = "block";
   currentLevel = 0;
   money = 100;
   lives = 10;
   score = 0;
   enemies = [];
   towers = [];
   bullets = [];
   document.getElementById("levelInfo").innerText = `Nå spiller du på: ${levels[currentLevel].name}`;
   spawnEnemy();
   gameInterval = setInterval(update, 1000 / 60);
   spawnInterval = setInterval(spawnEnemy, 2000);
 }
 // Move to the next level
 function nextLevel() {
   currentLevel++;
   if (currentLevel < levels.length) {
     money += 50; // Reward for moving to next level
     enemies = [];
     towers = [];
     bullets = [];
     document.getElementById("levelInfo").innerText = `Nå spiller du på: ${levels[currentLevel].name}`;
   } else {
     clearInterval(gameInterval);
     clearInterval(spawnInterval);
     alert("Gratulerer, du har fullført alle nivåene!");
   }
 }
 // Spawn an enemy
 function spawnEnemy() {
   enemies.push(new Enemy(levels[currentLevel]));
 }
 // Update the game state
 function update() {
   ctx.clearRect(0, 0, canvas.width, canvas.height);
   // Draw the path for the level
   ctx.strokeStyle = "gray";
   ctx.lineWidth = 40;
   ctx.beginPath();
   ctx.moveTo(levels[currentLevel].path[0].x, levels[currentLevel].path[0].y);
   for (let i = 1; i < levels[currentLevel].path.length; i++) {
     ctx.lineTo(levels[currentLevel].path[i].x, levels[currentLevel].path[i].y);
   }
   ctx.stroke();
   // Update and draw enemies, towers, and bullets
   enemies.forEach(e => e.update());
   towers.forEach(t => t.update());
   bullets.forEach(b => b.update());
   enemies = enemies.filter(e => e.hp > 0);
   bullets = bullets.filter(b => !b.dead);
   enemies.forEach(e => e.draw());
   towers.forEach(t => t.draw());
   bullets.forEach(b => b.draw());
   // Display stats
   document.getElementById("stats").innerText = `Penger: ${money} | Liv: ${lives}`;
   document.getElementById("score").innerText = `Poeng: ${score}`;
   // End the game if lives are depleted
   if (lives <= 0) {
     clearInterval(gameInterval);
     clearInterval(spawnInterval);
     alert("Game Over");
   }
 }
 // Tower placement on click (touch for mobile)
 canvas.addEventListener("click", (e) => {
   if (money < 50) return; // Ensure enough money to place tower
   const rect = canvas.getBoundingClientRect();
   const x = e.clientX - rect.left;
   const y = e.clientY - rect.top;
   towers.push(new Tower(x, y));
   money -= 50;
 });
 // Resize canvas based on window size
 window.addEventListener("resize", resizeCanvas);
 function resizeCanvas() {
   canvas.width = window.innerWidth;
   canvas.height = window.innerHeight - 100;
 }
 resizeCanvas(); // Set initial size
</script>
</body>
</html>
